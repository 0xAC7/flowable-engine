<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>CMMN 1.1 · Flowable Open Source Documentation</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## What is CMMN?"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="CMMN 1.1 · Flowable Open Source Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://flowable.com/open-source/docs/"/><meta property="og:description" content="## What is CMMN?"/><meta property="og:image" content="https://flowable.com/open-source/docs/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://flowable.com/open-source/docs/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/open-source/docs/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/open-source/docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/open-source/docs/css/main.css"/><script src="/open-source/docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/open-source/docs/"><img class="logo" src="/open-source/docs/img/flowable-oss-icon@2.png" alt="Flowable Open Source Documentation"/><h2 class="headerTitleWithLogo">Flowable Open Source Documentation</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/open-source/docs/oss-introduction" target="_self">Guides</a></li><li class=""><a href="/open-source/docs/all-javadocs" target="_self">Javadocs</a></li><li class=""><a href="https://flowable.com/open-source/" target="_self">Open source home</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>CMMN User Guide</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Flowable Open Source<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/open-source/docs/oss-introduction">Open Source Details</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">BPMN User Guide<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch02-GettingStarted">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch03-Configuration">Configuration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch04-API">The Flowable API</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch05-Spring">Spring integration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch05a-Spring-Boot">Spring Boot</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch06-Deployment">Deployment</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch07a-BPMN-Introduction">BPMN 2.0 Introduction</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch07b-BPMN-Constructs">BPMN 2.0 Constructs</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch08-Forms">Forms</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch09-ProcessInstanceMigration">Process Instance Migration (Experimental)</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch10-JPA">JPA</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch11-History">History</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch12-IDM">Identity management</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch13-Designer">Eclipse Designer</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch14-Applications">Flowable applications</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch15-REST">REST API</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch16-Cdi">CDI integration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch17-Ldap">LDAP integration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch18-Advanced">Advanced</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/bpmn/ch19-tooling">Tooling</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">CMMN User Guide<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/open-source/docs/cmmn/ch02-Configuration">Configuration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/cmmn/ch03-API">The Flowable CMMN API</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/cmmn/ch04-Spring">Spring integration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/cmmn/ch05-Deployment">Deployment</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/open-source/docs/cmmn/ch06-cmmn">CMMN 1.1</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/cmmn/ch07-architecture">Architecture</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">DMN User Guide<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/open-source/docs/dmn/ch02-Configuration">Configuration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/dmn/ch03-API">The Flowable DMN API</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/dmn/ch04-Spring">Spring integration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/dmn/ch05-Deployment">Deployment</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/dmn/ch06-DMN-Introduction">DMN 1.1 Introduction</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/dmn/ch07-REST">REST API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Forms User Guide<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/open-source/docs/form/ch02-Configuration">Configuration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/form/ch03-API">The Flowable Form API</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/form/ch04-Spring">Spring integration</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/form/ch05-Deployment">Deployment</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/form/ch06-Form-Introduction">Form Introduction</a></li><li class="navListItem"><a class="navItem" href="/open-source/docs/form/ch07-REST">REST API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Migration from v5<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/open-source/docs/migration">Flowable Migration Guide : Flowable or Activiti v5 to Flowable V6</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Disclaimer<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/open-source/docs/disclaimer">Disclaimer</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">CMMN 1.1</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="what-is-cmmn"></a><a href="#what-is-cmmn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is CMMN?</h2>
<p>The Case Management Model and Notation (CMMN) is a standard notation and formal specification by the <a href="http://www.omg.org/spec/CMMN/">Object Management Group</a> for representing case models.</p>
<p>Flowable contains:</p>
<ul>
<li><p>A CMMN 1.1 modeler to create CMMN 1.1 case models</p></li>
<li><p>A Java engine that can import and execute CMMN 1.1 case models</p></li>
<li><p>A demonstration UI that executes the case models, allowing users to see and complete human tasks (and their forms)</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="basic-concepts-and-terminology"></a><a href="#basic-concepts-and-terminology" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Basic concepts and terminology</h2>
<p>The following figure shows a simple CMMN 1.1 diagram:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn-basic-concepts.png" alt="cmmn basic concepts"></p>
<p>A <strong>case model</strong> is always visualized as some sort of <em>folder</em> that contains all the case elements. Every case model contains a <strong>plan model</strong> onto which items will be <em>planned</em>.</p>
<p>The elements of a plan model are called <strong>plan items</strong>. Each <em>plan item</em> has a <strong>plan item definition</strong> that gives its type and possible configuration options at runtime. For example, in the figure above, there are three <strong>human task</strong> plan items and one <strong>milestone</strong>. Other examples of plan items are <em>process tasks, case tasks and stages</em>.</p>
<p>After having deployed a case model to the Flowable CMMN engine, it’s possible to start <strong>case instances</strong> based on this case model. The plan items defined in the case model similarly have <strong>plan item instance</strong> runtime representations that are exposed by, and can be queried using, the Flowable API. Plan item instances have a state lifecycle that is defined in the CMMN 1.1 specification and is core to how the engine works. Please check out section 8.4.2 of the CMMN 1.1 specification for all the details.</p>
<p>Plan items can have <em>sentries</em>: a plan item is said to have <em>entry criteria</em> when a sentry &quot;guards&quot; its activation. These criteria specify conditions that must be satisfied to <em>trigger the sentry</em>. For example, in the figure above, the &quot;Milestone One&quot; plan item is <em>available</em> after a case instance is started, but it is <em>activated</em> (in CMMN 1.1 specification terminology: it moves from the <em>available</em> state to the <em>active</em> state) when both human task A and B are completed. Note that sentries can have complex expression in their <em>if part</em>, which are not visualized, allowing for much more complex functionality. Also note that there can be multiple sentries, although only one needs to be satisfied to trigger a state transition.</p>
<p>Plan items and the plan model can also have sentries with <em>exit criteria</em>, which specify conditions that trigger an <em>exit</em> from that particular plan item. In the figure above, the whole plan model is exited (as are all the child elements that are active at that moment), when human task C completes.</p>
<p>CMMN 1.1 defines a standard XML format in an XSD that is part of the specification. For information, the example in the figure above is represented in XML as shown below.</p>
<p>Some observations:</p>
<ul>
<li><p>The four plan items above are in the XML and they reference their definition with a <em>definitionRef</em>. The actual definitions are at the bottom of the <em>casePlanModel</em> element</p></li>
<li><p>The plan items have criteria (entry or exit) that reference a <em>sentry</em> (not the other way around)</p></li>
<li><p>The XML also contains information on how the diagram is visualized (x and y coordinates, widths and heights, and so on), which are omitted below. These elements are important when exchanging case models with other CMMN 1.1 modeling tools to preserve the correct visual representation</p></li>
</ul>
<!-- -->
<pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;definitions xmlns=&quot;http://www.omg.org/spec/CMMN/20151109/MODEL&quot;
             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
             xmlns:flowable=&quot;http://flowable.org/cmmn&quot;
             xmlns:cmmndi=&quot;http://www.omg.org/spec/CMMN/20151109/CMMNDI&quot;
             xmlns:dc=&quot;http://www.omg.org/spec/CMMN/20151109/DC&quot;
             xmlns:di=&quot;http://www.omg.org/spec/CMMN/20151109/DI&quot;
             targetNamespace=&quot;http://www.flowable.org/casedef&quot;&gt;
  &lt;case id=&quot;simpleExample&quot; name=&quot;Simple Example&quot;&gt;
    &lt;casePlanModel id=&quot;casePlanModel&quot; name=&quot;My Case&quot;&gt;
      &lt;planItem id=&quot;planItem1&quot; name=&quot;Human task A&quot;
            definitionRef=&quot;sid-88199E7C-7655-439C-810B-8849FC52D3EB&quot;&gt;&lt;/planItem&gt;
      &lt;planItem id=&quot;planItem2&quot; name=&quot;Milestone One&quot;
            definitionRef=&quot;sid-8BF8A774-A8A7-4F1A-95CF-1E0D61EE5A47&quot;&gt;
        &lt;entryCriterion id=&quot;sid-62CC4A6D-B29B-4129-93EA-460253C45CDF&quot;
            sentryRef=&quot;sentry1&quot;&gt;&lt;/entryCriterion&gt;
      &lt;/planItem&gt;
      &lt;planItem id=&quot;planItem3&quot; name=&quot;Human task B&quot;
            definitionRef=&quot;sid-A1FB8733-0DBC-4B38-9830-CBC4D0C4B802&quot;&gt;&lt;/planItem&gt;
      &lt;planItem id=&quot;planItem4&quot; name=&quot;Human task C&quot;
            definitionRef=&quot;sid-D3970AFC-7391-4BA7-95BA-51C64D2F41E9&quot;&gt;&lt;/planItem&gt;
      &lt;sentry id=&quot;sentry1&quot;&gt;
        &lt;planItemOnPart id=&quot;sentryOnPart1&quot; sourceRef=&quot;planItem1&quot;&gt;
          &lt;standardEvent&gt;complete&lt;/standardEvent&gt;
        &lt;/planItemOnPart&gt;
        &lt;planItemOnPart id=&quot;sentryOnPart2&quot; sourceRef=&quot;planItem3&quot;&gt;
          &lt;standardEvent&gt;complete&lt;/standardEvent&gt;
        &lt;/planItemOnPart&gt;
      &lt;/sentry&gt;
      &lt;sentry id=&quot;sentry2&quot;&gt;
        &lt;planItemOnPart id=&quot;sentryOnPart3&quot; sourceRef=&quot;planItem4&quot;&gt;
          &lt;standardEvent&gt;complete&lt;/standardEvent&gt;
        &lt;/planItemOnPart&gt;
      &lt;/sentry&gt;
      &lt;humanTask id=&quot;sid-88199E7C-7655-439C-810B-8849FC52D3EB&quot;
        name=&quot;Human task A&quot;&gt;&lt;/humanTask&gt;
      &lt;milestone id=&quot;sid-8BF8A774-A8A7-4F1A-95CF-1E0D61EE5A47&quot;
        name=&quot;Milestone One&quot;&gt;&lt;/milestone&gt;
      &lt;humanTask id=&quot;sid-A1FB8733-0DBC-4B38-9830-CBC4D0C4B802&quot;
        name=&quot;Human task B&quot;&gt;&lt;/humanTask&gt;
      &lt;humanTask id=&quot;sid-D3970AFC-7391-4BA7-95BA-51C64D2F41E9&quot;
        name=&quot;Human task C&quot;&gt;&lt;/humanTask&gt;
      &lt;exitCriterion id=&quot;sid-422626DB-9B40-49D8-955E-641AB96A5BFA&quot;
        sentryRef=&quot;sentry2&quot;&gt;&lt;/exitCriterion&gt;
    &lt;/casePlanModel&gt;
  &lt;/case&gt;
  &lt;cmmndi:CMMNDI&gt;
    &lt;cmmndi:CMMNDiagram id=&quot;CMMNDiagram_simpleExample&quot;&gt;
        ...
    &lt;/cmmndi:CMMNDiagram&gt;
  &lt;/cmmndi:CMMNDI&gt;
&lt;/definitions&gt;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="programmatic-example"></a><a href="#programmatic-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Programmatic example</h2>
<p>In this section we’re going to build a simple case model and execute it programmatically through the Java APIs of the Flowable CMMN engine in a simple command line example.</p>
<p>The case model we’ll build is a simplified <em>employee onboarding</em> case with two stages: a phase before and phase after the potential employee has started. In the first stage, someone from the HR department will complete the tasks, while in the second stage it is the employee completing them. Also, at any point in time, the potential employee can reject the job and stop the whole case instance.</p>
<p>Note that only stages and human tasks are used. In a real case model, there will most likely other plan item types too, such as milestones, nested stages, automated tasks, and so on.</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.programmatic.example.png" alt="cmmn.programmatic.example"></p>
<p>The XML for this case model is the following:</p>
<pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;definitions xmlns=&quot;http://www.omg.org/spec/CMMN/20151109/MODEL&quot;
             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
             xmlns:flowable=&quot;http://flowable.org/cmmn&quot;
             xmlns:cmmndi=&quot;http://www.omg.org/spec/CMMN/20151109/CMMNDI&quot;
             xmlns:dc=&quot;http://www.omg.org/spec/CMMN/20151109/DC&quot;
             xmlns:di=&quot;http://www.omg.org/spec/CMMN/20151109/DI&quot;
             targetNamespace=&quot;http://www.flowable.org/casedef&quot;&gt;
  &lt;case id=&quot;employeeOnboarding&quot; name=&quot;Simple Example&quot;&gt;
    &lt;casePlanModel id=&quot;casePlanModel&quot; name=&quot;My Case&quot;&gt;
      &lt;planItem id=&quot;planItem5&quot; name=&quot;Prior to starting&quot;
            definitionRef=&quot;sid-025D29E8-BA9B-403D-A684-8C5B52185642&quot;&gt;&lt;/planItem&gt;
      &lt;planItem id=&quot;planItem8&quot; name=&quot;After starting&quot;
            definitionRef=&quot;sid-8459EF32-4F4C-4E9B-A6E9-87FDC2299044&quot;&gt;
        &lt;entryCriterion id=&quot;sid-50B5F12D-FE75-4D05-9148-86574EE6C073&quot;
            sentryRef=&quot;sentry2&quot;&gt;&lt;/entryCriterion&gt;
      &lt;/planItem&gt;
      &lt;planItem id=&quot;planItem9&quot; name=&quot;Reject job&quot;
            definitionRef=&quot;sid-134E885A-3D58-417E-81E2-66A3E12334F9&quot;&gt;&lt;/planItem&gt;
      &lt;sentry id=&quot;sentry2&quot;&gt;
        &lt;planItemOnPart id=&quot;sentryOnPart4&quot; sourceRef=&quot;planItem5&quot;&gt;
          &lt;standardEvent&gt;complete&lt;/standardEvent&gt;
        &lt;/planItemOnPart&gt;
      &lt;/sentry&gt;
      &lt;sentry id=&quot;sentry3&quot;&gt;
        &lt;planItemOnPart id=&quot;sentryOnPart5&quot; sourceRef=&quot;planItem9&quot;&gt;
          &lt;standardEvent&gt;complete&lt;/standardEvent&gt;
        &lt;/planItemOnPart&gt;
      &lt;/sentry&gt;
      &lt;stage id=&quot;sid-025D29E8-BA9B-403D-A684-8C5B52185642&quot; name=&quot;Prior to starting&quot;&gt;
        &lt;planItem id=&quot;planItem1&quot; name=&quot;Create email address&quot;
                definitionRef=&quot;sid-EA434DDD-E1BE-4AC1-8520-B19ACE8782D2&quot;&gt;&lt;/planItem&gt;
        &lt;planItem id=&quot;planItem2&quot; name=&quot;Allocate office&quot;
                definitionRef=&quot;sid-505BA223-131A-4EF0-ABAD-485AEB0F2C96&quot;&gt;&lt;/planItem&gt;
        &lt;planItem id=&quot;planItem3&quot; name=&quot;Send joining letter to candidate&quot;
                definitionRef=&quot;sid-D28DBAD5-0F5F-45F4-8553-3381199AC45F&quot;&gt;
          &lt;entryCriterion id=&quot;sid-4D88C79D-8E31-4246-9541-A4F6A5720AC8&quot;
            sentryRef=&quot;sentry1&quot;&gt;&lt;/entryCriterion&gt;
        &lt;/planItem&gt;
        &lt;planItem id=&quot;planItem4&quot; name=&quot;Agree start date&quot;
                definitionRef=&quot;sid-97A72C46-C0AD-477F-86DD-85EF643BB97D&quot;&gt;&lt;/planItem&gt;
        &lt;sentry id=&quot;sentry1&quot;&gt;
          &lt;planItemOnPart id=&quot;sentryOnPart1&quot; sourceRef=&quot;planItem1&quot;&gt;
            &lt;standardEvent&gt;complete&lt;/standardEvent&gt;
          &lt;/planItemOnPart&gt;
          &lt;planItemOnPart id=&quot;sentryOnPart2&quot; sourceRef=&quot;planItem2&quot;&gt;
            &lt;standardEvent&gt;complete&lt;/standardEvent&gt;
          &lt;/planItemOnPart&gt;
          &lt;planItemOnPart id=&quot;sentryOnPart3&quot; sourceRef=&quot;planItem4&quot;&gt;
            &lt;standardEvent&gt;complete&lt;/standardEvent&gt;
          &lt;/planItemOnPart&gt;
        &lt;/sentry&gt;
        &lt;humanTask id=&quot;sid-EA434DDD-E1BE-4AC1-8520-B19ACE8782D2&quot;
            name=&quot;Create email address&quot;
            flowable:candidateGroups=&quot;hr&quot;&gt;&lt;/humanTask&gt;
        &lt;humanTask id=&quot;sid-505BA223-131A-4EF0-ABAD-485AEB0F2C96&quot;
            name=&quot;Allocate office&quot;
            flowable:candidateGroups=&quot;hr&quot;&gt;&lt;/humanTask&gt;
        &lt;humanTask id=&quot;sid-D28DBAD5-0F5F-45F4-8553-3381199AC45F&quot;
            name=&quot;Send joining letter to candidate&quot;
            flowable:candidateGroups=&quot;hr&quot;&gt;&lt;/humanTask&gt;
        &lt;humanTask id=&quot;sid-97A72C46-C0AD-477F-86DD-85EF643BB97D&quot;
            name=&quot;Agree start date&quot;
            flowable:candidateGroups=&quot;hr&quot;&gt;&lt;/humanTask&gt;
      &lt;/stage&gt;
      &lt;stage id=&quot;sid-8459EF32-4F4C-4E9B-A6E9-87FDC2299044&quot;
        name=&quot;After starting&quot;&gt;
        &lt;planItem id=&quot;planItem6&quot; name=&quot;New starter training&quot;
                definitionRef=&quot;sid-DF7B9582-11A6-40B4-B7E5-EC7AC6029387&quot;&gt;&lt;/planItem&gt;
        &lt;planItem id=&quot;planItem7&quot; name=&quot;Fill in paperwork&quot;
                definitionRef=&quot;sid-7BF2B421-7FA0-479D-A8BD-C22EBD09F599&quot;&gt;&lt;/planItem&gt;
        &lt;humanTask id=&quot;sid-DF7B9582-11A6-40B4-B7E5-EC7AC6029387&quot;
            name=&quot;New starter training&quot;
            flowable:assignee=&quot;${potentialEmployee}&quot;&gt;&lt;/humanTask&gt;
        &lt;humanTask id=&quot;sid-7BF2B421-7FA0-479D-A8BD-C22EBD09F599&quot;
            name=&quot;Fill in paperwork&quot;
            flowable:assignee=&quot;${potentialEmployee}&quot;&gt;&lt;/humanTask&gt;
      &lt;/stage&gt;
      &lt;humanTask id=&quot;sid-134E885A-3D58-417E-81E2-66A3E12334F9&quot; name=&quot;Reject job&quot;
        flowable:assignee=&quot;${potentialEmployee}&quot;&gt;&lt;/humanTask&gt;
      &lt;exitCriterion id=&quot;sid-18277F30-E146-4B3E-B3C9-3F1E187EC7A8&quot;
        sentryRef=&quot;sentry3&quot;&gt;&lt;/exitCriterion&gt;
    &lt;/casePlanModel&gt;
  &lt;/case&gt;
&lt;/definitions&gt;
</code></pre>
<p>First of all, create a new project and add the <em>flowable-cmmn-engine</em> dependency (here shown for Maven). The H2 dependency is also added, as H2 will be used as embedded database later on.</p>
<pre><code class="hljs">&lt;dependency&gt;
    &lt;groupId&gt;org.flowable&lt;/groupId&gt;
    &lt;artifactId&gt;flowable-cmmn-engine&lt;/artifactId&gt;
    &lt;version&gt;${flowable.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;version&gt;${h2.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>The Flowable CMMN API is designed to be consistent with the other Flowable APIs and concepts. As such, people that know the BPMN or DMN APIs will have no problem finding their way around. As with the other engines, the first line of code is creating a CmmnEngine. Here, the default in-memory configuration is used, which uses H2 as the database:</p>
<pre><code class="hljs">public class Main {
  public static void main(String[] args) {
    CmmnEngine cmmnEngine
        = new StandaloneInMemCmmnEngineConfiguration().buildCmmnEngine();
  }
}
</code></pre>
<p>Note that the <em>CmmnEngineConfiguration</em> exposes many configuration options for tweaking various settings of the CMMN engine.</p>
<p>Put the XML from above in a file, for example <em>my-case.cmmn</em> (or .cmmn.xml). For Maven, it should be placed in the <em>src/main/resources</em> folder.</p>
<p>To make the engine aware of the case model, it first needs to be <em>deployed</em>. This is done through the <em>CmmnRepositoryService</em>:</p>
<pre><code class="hljs">CmmnRepositoryService cmmnRepositoryService = cmmnEngine.getCmmnRepositoryService();
CmmnDeployment cmmnDeployment = cmmnRepositoryService.createDeployment()
    .addClasspathResource(&quot;my-case.cmmn&quot;)
    .deploy();
</code></pre>
<p>Deploying the XML will return a <strong>CmmnDeployment</strong>. A deployment can contain many case models and artifacts. The specific case model definition above is stored as a <strong>CaseDefinition</strong>. This can be verified by doing a <em>CaseDefinitionQuery</em>:</p>
<pre><code class="hljs">List&lt;CaseDefinition&gt; caseDefinitions = cmmnRepositoryService.createCaseDefinitionQuery().list();
System.out.println(&quot;Found &quot; + caseDefinitions.size() + &quot; case definitions&quot;);
</code></pre>
<p>Having a <strong>CaseDefinition</strong> in the engine, it’s now possible to start a <strong>CaseInstance</strong> for this case model definition. Either the result from the query is used and passed into the following snippet of code, or the <em>key</em> of the case definition is used directly (as done below).</p>
<p>Note that we’re also passing data, an identifier to the <em>potentialEmployee</em> as a variable when starting the <strong>CaseInstance</strong>. This variable will later be used in the human tasks to assign the task to the correct person (see the <em>assignee=&quot;${potentialEmployee}&quot;</em> attribute on <em>human tasks</em>).</p>
<pre><code class="hljs">CmmnRuntimeService cmmnRuntimeService = cmmnEngine.getCmmnRuntimeService();
CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
    .caseDefinitionKey(&quot;employeeOnboarding&quot;)
    .variable(&quot;potentialEmployee&quot;, &quot;johnDoe&quot;)
    .start();
</code></pre>
<p>After the <strong>CaseInstance</strong> is started, the engine will determine which of the plan items of the model should be activated:</p>
<ul>
<li><p>The first stage has no entry criteria, so it’s activated</p></li>
<li><p>The child human tasks of the first stage have no entry criteria, so three of them are expected to be active</p></li>
</ul>
<p>The plan items are represented at runtime by <strong>PlanItemInstances</strong> and can be queried through the <em>CmmnRuntimeService</em>:</p>
<pre><code class="hljs">List&lt;PlanItemInstance&gt; planItemInstances = cmmnRuntimeService.createPlanItemInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .orderByName().asc()
    .list();

for (PlanItemInstance planItemInstance : planItemInstances) {
    System.out.println(planItemInstance.getName());
}
</code></pre>
<p>which prints out</p>
<pre><code class="hljs">After starting
Agree start date
Allocate office
Create email address
Prior to starting
Reject job
Send joining letter to candidate
</code></pre>
<p>Some things might be unexpected here:</p>
<ul>
<li><p>The stages are <em>also</em> plan items and thus have a representation as <strong>PlanItemInstance</strong>. Note that that child plan item instances will have the stage as parent when calling <em>.getStageInstanceId()</em>.</p></li>
<li><p>The <em>Send joining letter to candidate</em> is returned in the result. The reason is that, in accordance with the CMMN 1.1 specification, this plan item instance is in the <em>available</em> state, but not yet in the <em>active</em> state.</p></li>
</ul>
<p>Indeed, when the code above is changed to</p>
<pre><code class="hljs">for (PlanItemInstance planItemInstance : planItemInstances) {
    System.out.println(planItemInstance.getName()
        + &quot;, state=&quot; + planItemInstance.getState()
        + &quot;, parent stage=&quot; + planItemInstance.getStageInstanceId());
}
</code></pre>
<p>The output now becomes:</p>
<pre><code class="hljs">After starting, state=available, parent stage=null
Agree start date, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Allocate office, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Create email address, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Prior to starting, state=active, parent stage=null
Reject job, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Send joining letter to candidate, state=available, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
</code></pre>
<p>To only show the active plan item instances, the query can be adapted by adding <em>planItemInstanceStateActive()</em>:</p>
<pre><code class="hljs"> List&lt;PlanItemInstance&gt; planItemInstances = cmmnRuntimeService.createPlanItemInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .planItemInstanceStateActive()
    .orderByName().asc()
    .list();
</code></pre>
<p>The output is now</p>
<pre><code class="hljs">Agree start date
Allocate office
Create email address
Prior to starting
Reject job
</code></pre>
<p>Of course, the <strong>PlanItemInstance</strong> is the low level representation, but each plan item also has a <em>plan item definition</em> that defines what type it is. In this case, we only have <em>human tasks</em>. It is possible to interact with the <em>CaseInstance</em> via its <em>plan item instances</em>, for example by triggering them programmatically (for example, <em>CmmnRuntimeService.triggerPlanItemInstance(String planItemInstanceId)</em>). However, most likely the interaction will happen through the results of the actual plan item definition: here, the human tasks.</p>
<p>Querying for tasks is done in the exact same way as for the BPMN engine (in fact, the task service is a shared component and tasks created in BPMN or CMMN can be queried through both engines):</p>
<pre><code class="hljs">CmmnTaskService cmmnTaskService = cmmnEngine.getCmmnTaskService();
List&lt;Task&gt; hrTasks = cmmnTaskService.createTaskQuery()
    .taskCandidateGroup(&quot;hr&quot;)
    .caseInstanceId(caseInstance.getId())
    .orderByTaskName().asc()
    .list();
for (Task task : hrTasks) {
    System.out.println(&quot;Task for HR : &quot; + task.getName());
}

List&lt;Task&gt; employeeTasks = cmmnTaskService.createTaskQuery()
    .taskAssignee(&quot;johndoe&quot;)
    .orderByTaskName().asc()
    .list();
for (Task task : employeeTasks) {
    System.out.println(&quot;Task for employee: &quot; + task);
}
</code></pre>
<p>Which outputs:</p>
<pre><code class="hljs">Task for HR : Agree start date
Task for HR : Allocate office
Task for HR : Create email address

Task for employee: Reject job
</code></pre>
<p>When the three tasks of HR are completed, the 'Send joining letter to candidate' task should be available:</p>
<pre><code class="hljs">for (Task task : hrTasks) {
    cmmnTaskService.complete(task.getId());
}

hrTasks = cmmnTaskService.createTaskQuery()
    .taskCandidateGroup(&quot;hr&quot;)
    .caseInstanceId(caseInstance.getId())
    .orderByTaskName().asc()
    .list();

for (Task task : hrTasks) {
    System.out.println(&quot;Task for HR : &quot; + task.getName());
}
</code></pre>
<p>And indeed, the expected task is now created:</p>
<pre><code class="hljs">Task for HR : Send joining letter to candidate
</code></pre>
<p>Completing this task will now move the case instance into the second stage, as the sentry for the first stage is satisfied. The 'Reject job' tasks is automatically completed by the system and the two tasks for the employee are created:</p>
<pre><code class="hljs">Task for employee: Fill in paperwork
Task for employee: New starter training
Task for employee: Reject job
</code></pre>
<p>Completing all the tasks will end the case instance:</p>
<pre><code class="hljs">List&lt;Task&gt; tasks = cmmnTaskService.createTaskQuery().caseInstanceId(caseInstance.getId()).listPage(0, 1);
while (!tasks.isEmpty()) {
    cmmnTaskService.complete(tasks.get(0).getId());
    tasks = cmmnTaskService.createTaskQuery()
        .caseInstanceId(caseInstance.getId())
        .listPage(0, 1);
}
</code></pre>
<p>While executing case instances, the engine also stores historic information, which can be queried via a query API:</p>
<pre><code class="hljs">CmmnHistoryService cmmnHistoryService = cmmnEngine.getCmmnHistoryService();
HistoricCaseInstance historicCaseInstance = cmmnHistoryService.createHistoricCaseInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .singleResult();

System.out.println(&quot;Case instance execution took &quot;
    + (historicCaseInstance.getEndTime().getTime() - historicCaseInstance.getStartTime().getTime()) + &quot; ms&quot;);

List&lt;HistoricTaskInstance&gt; historicTaskInstances = cmmnHistoryService.createHistoricTaskInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .orderByTaskCreateTime().asc()
    .list();

for (HistoricTaskInstance historicTaskInstance : historicTaskInstances) {
    System.out.println(&quot;Task completed: &quot; + historicTaskInstance.getName());
}
</code></pre>
<p>Which outputs:</p>
<pre><code class="hljs">Case instance execution took 149 ms
Task completed: Reject job
Task completed: Agree start date
Task completed: Allocate office
Task completed: Create email address
Task completed: Send joining letter to candidate
Task completed: New starter training
Task completed: Fill in paperwork
</code></pre>
<p>Historic data related to the case execution is collected for special constructs, such as Tasks (as seen above), milestones, cases, variables and plan items in general.
This data is persisted at the same time as the runtime data, but it is not deleted when case instances end.
Access to the historic data is provided as query APIs by the <em>CmmnHistoryService</em></p>
<p>Of course, this is but a small part of the available APIs and constructs available in the Flowable CMMN Engine. Please check the other sections for more detailed information</p>
<h2><a class="anchor" aria-hidden="true" id="cmmn-11-constructs"></a><a href="#cmmn-11-constructs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CMMN 1.1 Constructs</h2>
<p>This chapter covers the CMMN 1.1 constructs supported by Flowable, as well as extensions to the CMMN 1.1 standard.</p>
<p>The following constructs, with the exception of sentries and item control, as for the CMMN specification are considered plan items.
Historic data of their instances execution can be queried through the <em>CmmnHistoryService</em> using <em>org.flowable.cmmn.api.history.HistoricPlanItemInstanceQuery</em>.</p>
<h3><a class="anchor" aria-hidden="true" id="stage"></a><a href="#stage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stage</h3>
<p>A stage is used to group plan items together. It is typically used to define &quot;phases&quot; in a case instance.</p>
<p>A stage is a plan item itself, and thus can have entry and exit criteria. Plan items contained within a stage are only available when the parent stage moves to the <em>active</em> state. Stages can be nested in other stages.</p>
<p>A stage is visualized as a rectangle with angled corners:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.stage.png" alt="cmmn.stage"></p>
<h3><a class="anchor" aria-hidden="true" id="task"></a><a href="#task" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Task</h3>
<p>A &quot;manual&quot; task, meaning the task will happen external to the engine.</p>
<p>Properties:</p>
<ul>
<li><p><strong>name</strong>: expression that will be resolved at runtime as the name of the manual task</p></li>
<li><p><strong>blocking</strong>: a boolean value determining whether the task blocks</p></li>
<li><p><strong>blockingExpression</strong>: an expression that evaluates to a boolean indicating whether the tasks blocks</p></li>
</ul>
<p>If a task is non-blocking, the engine will simply complete it automatically when executing it. If a task is blocking, a <em>PlanItemInstance</em> for this task will remain in the <em>active</em> state until it is programmatically triggered by the <em>CmmnRuntimeService.triggerPlanItemInstance(String planItemInstanceId)</em> method.</p>
<p>A task is visualized as a rounded rectangle:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.task.png" alt="cmmn.task"></p>
<h3><a class="anchor" aria-hidden="true" id="human-task"></a><a href="#human-task" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Human task</h3>
<p>A human task is used to model work that needs to be done by a human, typically through a form. When the engine arrives at a human task, a new entry is created in the task list of any users or groups assigned to that task.</p>
<p>A human task is a plan item, which means that beyond a human task entry also a <em>PlanItemInstance</em> is created and it can be queried via the <em>PlanItemInstanceQuery</em>.</p>
<p>Human tasks can be queried through the <em>org.flowable.task.api.TaskQuery</em> API. Historic task data can be queried through the <em>org.flowable.task.api.history.HistoricTaskInstanceQuery</em>.</p>
<p>Properties:</p>
<ul>
<li><p><strong>name</strong>: expression that will be resolved at runtime as the name of the human task</p></li>
<li><p><strong>blocking</strong>: a boolean value determining whether the task blocks</p></li>
<li><p><strong>blockingExpression</strong>: an expression that evaluates to a boolean indicating whether the tasks blocks</p></li>
<li><p><strong>assignee</strong> : an expression (can be a static text value) that is used to determine to whom the human task is assigned</p></li>
<li><p><strong>owner</strong> : an expression (can be a static text value) that is used to determine who is the owner of the human task</p></li>
<li><p><strong>candidateUsers</strong> : an expression (can be a static text value) that resolves to a comma-separated list of Strings that is used to determine which users are candidate for this human task</p></li>
<li><p><strong>candidateGroups</strong> : an expression (can be a static text value) that resolves to a comma-separated list of Strings that is used to determine to which groups the task is assigned</p></li>
<li><p><strong>form key</strong>: an expression that determines a key when using forms. Can be retrieved via the API afterwards</p></li>
<li><p><strong>Due date</strong> an expression that resolves to java.util.Date or a ISO-8601 date string</p></li>
<li><p><strong>Priority</strong>: an expression that resolves to an integer. Can be used in the TaskQuery API to filter tasks</p></li>
</ul>
<p>A human task is visualized as a rounded rectangle with a user icon in the top left corner:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.humantask.png" alt="cmmn.humantask"></p>
<h3><a class="anchor" aria-hidden="true" id="java-service-task"></a><a href="#java-service-task" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Java Service task</h3>
<p>A service task is used to execute custom logic.</p>
<p>Custom logic is placed in a class that implements the <em>org.flowable.cmmn.api.delegate.PlanItemJavaDelegate</em> interface.</p>
<pre><code class="hljs">public class MyJavaDelegate implements PlanItemJavaDelegate {

    public void execute(DelegatePlanItemInstance planItemInstance) {
        String value = (String) planItemInstance.getVariable(&quot;someVariable&quot;);
        ...
    }

}
</code></pre>
<p>For lower-level implementations that cannot be covered by using the <em>PlanItemJavaDelegate</em> approach, the <em>CmmnActivityBehavior</em> can be used (similar to <em>JavaDelegate</em> vs <em>ActivityBehavior</em> in the BPMN engine).</p>
<p>Properties:</p>
<ul>
<li><p><strong>name</strong>: name of the service task</p></li>
<li><p><strong>class</strong>: the Java class implementing the custom logic</p></li>
<li><p><strong>class fields</strong>: parameters to pass when calling the custom logic</p></li>
<li><p><strong>Delegate expression</strong>: an expression that resolves to a class implementing the <em>PlanItemJavaDelegate</em> interface</p></li>
</ul>
<p>A service task is visualized as a rounded rectangle with a cog icon in the top left corner:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.servicetask.png" alt="cmmn.servicetask"></p>
<h3><a class="anchor" aria-hidden="true" id="decision-task"></a><a href="#decision-task" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Decision task</h3>
<p>A <em>Decision task</em> calls out to a DMN decision table and stores the resulting variable in the case instance.</p>
<p>Properties:</p>
<ul>
<li><strong>Decision table reference</strong>: the referenced DMN decision table that needs to be invoked.</li>
</ul>
<p>It is also possible to throw an error when no rule is hit during the evaluation of the DMN decision table by setting the '<em>Throw error if no rules were hit</em>' property.</p>
<p>A decision task is visualized as a <em>task</em> with a table icon in the top left corner:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.decisiontask.png" alt="cmmn.decisiontask"></p>
<h3><a class="anchor" aria-hidden="true" id="http-task"></a><a href="#http-task" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Http Task</h3>
<p>The Http task is an out-of-the-box implementation of a <em>service task</em>. It is used when a REST service needs to be called over HTTP.</p>
<p>The Http task has various options to customize the request and response. See the BPMN http task documentation for details on all the configuration options.</p>
<p>A http task is visualized as a <em>task</em> with a rocket icon in the top left corner:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.httptask.png" alt="cmmn.httptask"></p>
<h3><a class="anchor" aria-hidden="true" id="script-task"></a><a href="#script-task" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Script Task</h3>
<p>A task of type &quot;script&quot;, similar to its equivalent in BPMN, the Script Task executes a script when the plan item instance becomes active.</p>
<p>Properties:</p>
<ul>
<li><p><strong>name</strong>: task attribute to indicate the name of the task</p></li>
<li><p><strong>type</strong>: task attribute whose value must be &quot;script&quot; to indicate the type of task</p></li>
<li><p><strong>scriptFormat</strong>: extended attribute that indicate the language of the script (for example, javascript, groovy)</p></li>
<li><p><strong>script</strong>: the script to execute, defined as a string in a field element named &quot;script&quot;</p></li>
<li><p><strong>autoStoreVariables</strong>: optional task attribute flag (default: false) that indicates whether or not variables defined in the script will be stored in the Plan Item Instance context (see note below)</p></li>
<li><p><strong>resultVariableName</strong>: optional task attribute that when present will store a variable with the specified name in the Plan Item instance context with the script evaluation result (see note below)</p></li>
</ul>
<p>A script task is visualized as a <em>task</em> with a script icon in the top left corner:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.scripttask.png" alt="cmmn.scripttask"></p>
<pre><code class="hljs">&lt;planItem id=&quot;scriptPlanItem&quot; name=&quot;Script Plan Item&quot; definitionRef=&quot;myScriptTask&quot; /&gt;
&lt;task name=&quot;My Script Task Item&quot; flowable:type=&quot;script&quot; flowable:scriptFormat=&quot;JavaScript&quot;&gt;
    &lt;documentation&gt;Optional documentation&lt;/documentation&gt;
    &lt;extensionElements&gt;
        &lt;flowable:field name=&quot;script&quot;&gt;
            &lt;string&gt;
                sum = 0;
                for ( i in inputArray ) {
                    sum += i;
                }
            &lt;/string&gt;
        &lt;/flowable:field&gt;
    &lt;/extensionElements&gt;
&lt;/task&gt;
</code></pre>
<p><strong>Note</strong>: The value of the <strong>scriptFormat</strong> attribute must be a name that is compatible with the <a href="http://jcp.org/en/jsr/detail?id=223">JSR-223</a> (scripting for the Java platform). By default, JavaScript is included in every JDK and as such doesn’t need any additional JAR files. If you want to use another (JSR-223 compatible) scripting engine, it is sufficient to add the corresponding JAR to the classpath and use the appropriate name. For example, the Flowable unit tests often use Groovy because the syntax is similar to that of Java.</p>
<p>Do note that the Groovy scripting engine is bundled with the groovy-jsr223 JAR. As such, one must add the following dependency:</p>
<pre><code class="hljs">&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt;
    &lt;artifactId&gt;groovy-jsr223&lt;/artifactId&gt;
    &lt;version&gt;2.x.x&lt;version&gt;
&lt;/dependency&gt;
</code></pre>
<p>All case variables that are accessible through the PlanItem instance that arrives in the script task can be used within the script. In the example below, the script variable <em>'inputArray'</em> is in fact a case variable (an array of integers).</p>
<pre><code class="hljs">&lt;flowable:field name=&quot;script&quot;&gt;
    &lt;string&gt;
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
    &lt;/string&gt;
&lt;/flowable:field&gt;
</code></pre>
<p><strong>Note</strong>: It’s also possible to set plan item instance variables in a script, simply by calling <em>planItemInstance.setVariable(&quot;variableName&quot;, variableValue)</em>. By default, no variables are stored automatically. It’s possible to automatically store any variable defined in the script (for example, <em>sum</em> in the example above) by setting the property autoStoreVariables on the scriptTask to true. However, <strong>the best practice is not to do this and use an explicit planItemInstance.setVariable() call</strong>, as with some recent versions of the JDK, auto storing of variables does not work for some scripting languages. See <a href="http://www.jorambarrez.be/blog/2013/03/25/bug-on-jdk-1-7-0_17-when-using-scripttask-in-activiti/">this link</a> for more details.</p>
<pre><code class="hljs">&lt;task name=&quot;Script Task&quot; flowable:type=&quot;script&quot; flowable:scriptFormat=&quot;groovy&quot; flowable:autoStoreVariables=&quot;false&quot;&gt;
</code></pre>
<p>The default for this parameter is false, meaning that if the parameter is omitted from the script task definition, all the declared variables will only exist during the duration of the script.</p>
<p>Here’s an example of how to set a variable in a script:</p>
<pre><code class="hljs">&lt;flowable:field name=&quot;script&quot;&gt;
    &lt;string&gt;
    def scriptVar = &quot;test123&quot;
    planItemInstance.setVariable(&quot;myVar&quot;, scriptVar)
    &lt;/string&gt;
&lt;/flowable:field&gt;
</code></pre>
<p>The following names are reserved and <strong>cannot be used</strong> as variable names: <strong>out, out:print, lang:import, context, elcontext</strong>.</p>
<p><strong>Note</strong> The return value of a script task can be assigned to an already existing or new plan item instance variable by specifying its name as a literal value for the <em>'flowable:resultVariable'</em> attribute of a script task definition. Any existing value for a specific plan item instance variable will be overwritten by the result value of the script execution. When a result variable name is not specified, the script result value gets ignored.</p>
<pre><code class="hljs">&lt;task name=&quot;Script Task&quot; flowable:type=&quot;script&quot; flowable:scriptFormat=&quot;groovy&quot; flowable:resultVariable=&quot;myVar&quot;&gt;
    &lt;flowable:field name=&quot;script&quot;&gt;
        &lt;string&gt;#{echo}&lt;/string&gt;
    &lt;/flowable:field&gt;
&lt;/task&gt;
</code></pre>
<p>In the above example, the result of the script execution (the value of the resolved expression <em>'#{echo}'</em>) is set to the process variable named <em>'myVar'</em> after the script completes.</p>
<h3><a class="anchor" aria-hidden="true" id="milestone"></a><a href="#milestone" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Milestone</h3>
<p>A milestone is used to mark arriving at a certain point in the case instance. At runtime, they are represented as <strong>MilestoneInstances</strong> and they can be queried through the <strong>MilestoneInstanceQuery</strong> via the <em>CmmnRuntimeService</em>. There is also a historical counterpart via the <em>CmmnHistoryService</em>.</p>
<p>A milestone is a plan item, which means that as well as a milestone entry, a <em>PlanItemInstance</em> is created also, which can be queried via the <em>PlanItemInstanceQuery</em>.</p>
<p>Properties:</p>
<ul>
<li><strong>name</strong>: an expression or static text that determines the name of the milestone</li>
</ul>
<p>A milestone is visualized as a rounded rectangle (more rounded than a task):</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.milestone.png" alt="cmmn.milestone"></p>
<h3><a class="anchor" aria-hidden="true" id="case-task"></a><a href="#case-task" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Case task</h3>
<p>A case task is used to start a child case within the context of another case. The <em>CaseInstanceQuery</em> has <em>parent</em> options to find these cases.</p>
<p>When the case task is blocking, the <em>PlanItemInstance</em> will be <em>active</em> until the child case has completely finished. If the case task is non-blocking, the child case is started and the plan item instance automatically completes. When the child case instance ends there is no impact on the parent case.</p>
<p>Properties:</p>
<ul>
<li><p><strong>name</strong>: an expression or static text that determines the name</p></li>
<li><p><strong>blocking</strong>: a boolean value determining whether the task blocks</p></li>
<li><p><strong>blockingExpression</strong>: an expression that evaluates to a boolean indicating whether the tasks blocks</p></li>
<li><p><strong>Case reference</strong>: the key of the case definition that is used to start the child case instance. Can be an expression</p></li>
</ul>
<p>A case task is visualized as a rounded rectangle with a case icon in the top left corner:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.casetask.png" alt="cmmn.casetask"></p>
<h3><a class="anchor" aria-hidden="true" id="process-task"></a><a href="#process-task" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Process task</h3>
<p>A process task is used to start a process instance within the context of a case.</p>
<p>When the process task is blocking, the <em>PlanItemInstance</em> will be <em>active</em> until the process instance has completely finished. If the process task is non-blocking, the process instance is started and the plan item instance automatically completes. When the process instance ends there is no impact on the parent case.</p>
<p>Properties:</p>
<ul>
<li><p><strong>name</strong>: an expression or static text that determines the name</p></li>
<li><p><strong>blocking</strong>: a boolean value determining whether the task blocks</p></li>
<li><p><strong>blockingExpression</strong>: an expression that evaluates to a boolean indicating whether the tasks blocks</p></li>
<li><p><strong>Process reference</strong>: the key of the process definition that is used to start the process instance. Can be an expression</p></li>
</ul>
<p>A process task is visualized as a rounded rectangle with an arrow icon in the top left corner:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.processtask.png" alt="cmmn.processtask"></p>
<p>A process task can be configured to have in- and out parameters, which take the form of <em>source/sourceExpression</em> and <em>target/targetExpression</em>.</p>
<p>The in parameters are resolved within context of the case instance.</p>
<ul>
<li><p>The <em>source</em> value will be the case instance variable which value will be mapped to a process variable</p></li>
<li><p>Alternatively, the <em>sourceExpression</em> allows to create an arbitrary value, where the expression is resolved against the case instance.</p></li>
<li><p>The <em>target</em> will be the name of the process variable to which the source value is mapped.</p></li>
<li><p>Alternatively, the <em>targetExpression</em> will resolve to a <strong>string</strong> value that is used as variable name in the process instance. The expression is resolved within case instance context.</p></li>
</ul>
<p>The out parameters are resolved within context of the process instance.</p>
<ul>
<li><p>The <em>source</em> value will be the process instance variable which value will be mapped to a case variable</p></li>
<li><p>Alternatively, the <em>sourceExpression</em> allows to create an arbitrary value, where the expression is resolved against the process instance.</p></li>
<li><p>The <em>target</em> will be the name of the case variable to which the source value is mapped.</p></li>
<li><p>Alternatively, the <em>targetExpression</em> will resolve to a <strong>string</strong> value that is used as variable name in the case instance. The expression is resolved within process instance context.</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="criteria"></a><a href="#criteria" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Criteria</h3>
<h4><a class="anchor" aria-hidden="true" id="entry-criterion-entry-sentry"></a><a href="#entry-criterion-entry-sentry" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Entry criterion (entry sentry)</h4>
<p>Entry criteria form a sentry for a given plan item instance. They consist of two parts:</p>
<ul>
<li><p>One or more parts that depend on other plan items: these define dependencies on state transitions of other plan items. For example, one human task can depend on the state transition 'complete' of three other human tasks to become active itself</p></li>
<li><p>One optional <em>if part</em> or <em>condition</em>: this is an expression that allows the definition of a complex condition</p></li>
</ul>
<p>A sentry is satisfied when all its criteria are resolved to <em>true</em>. When a criterion evaluates to true, this is stored and remembered for future evaluations. Note that entry criteria of all plan item instances in the <em>available</em> state are evaluated whenever something changes in the case instance.
Multiple sentries are possible on a plan item. However, when one is satisfied, the plan item moves from state <em>available</em> to <em>active</em>.</p>
<p>See <a href="/open-source/docs/cmmn/ch06-cmmn#sentry-evaluation">the section on sentry evaluation</a> for more information.</p>
<p>An entry criterion is visualized as a diamond shape (white color inside) on the border of a plan item:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.entrycriteria.png" alt="cmmn.entrycriteria"></p>
<h4><a class="anchor" aria-hidden="true" id="exit-criterion-exit-sentry"></a><a href="#exit-criterion-exit-sentry" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exit criterion (exit sentry)</h4>
<p>Exit criteria form a sentry for a given plan item instance. They consist of two parts:</p>
<ul>
<li><p>One or more parts that depend on other plan items: these define dependencies on state transitions of other plan items. For example, one human task can depend on reaching a certain milestone to be automatically terminated</p></li>
<li><p>One optional <em>if part</em> or <em>condition</em>: this is an expression that allows a complex condition to be defined</p></li>
</ul>
<p>A sentry is satisfied when all its criteria are resolved to <em>true</em>. When a criterion evaluates to true, this is stored and remembered for future evaluations. Note that exit criteria of all plan item instances in the <em>active</em> state are evaluated whenever something changes in the case instance.
Multiple sentries are possible on a plan item. However, when one is satisfied, the plan item moves from state <em>active</em> to <em>exit</em>.</p>
<p>See <a href="/open-source/docs/cmmn/ch06-cmmn#sentry-evaluation">the section on sentry evaluation</a> for more information.</p>
<p>An exit criterion is visualized as a diamond shape (white color inside) on the border of a plan item:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.exitcriteria.png" alt="cmmn.exitcriteria"></p>
<p>Beyond the specification, Flowable supports additional attributes on an exit sentry which adds more flexibility and options on how a plan item is terminated when the exit sentry triggers.</p>
<h5><a class="anchor" aria-hidden="true" id="exittype"></a><a href="#exittype" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>exitType</h5>
<p>This attribute can be used for exit sentries on plan items, not stages or the case plan model though, and helps define how to exit the plan item.
It particularly makes sense in combination with repetition. A possible use case might be that you want to terminate active instances of a repetitive plan item, but maybe later on it becomes available again as the conditions change in the case. With the exit type other than the default, this is possible as the plan item is not terminated for good, but only active or active and enabled instances.</p>
<p>Possible values are:</p>
<ul>
<li><p><strong>default</strong>: The default exit type works as the spec says, it will terminate (exit) the plan item and all not yet finished instances as well.</p></li>
<li><p><strong>activeInstances</strong>: If this exit type is chosen, the exit sentry only terminates active instances, but leaves enabled, available ones in place, so they can become active later on.</p></li>
<li><p><strong>activeAndEnabledInstances</strong>: In addition to the previous one, this exit type also terminates enabled instances (e.g. ready for manual activation), but leaves available ones in place.</p></li>
</ul>
<p>Example of an extended exit sentry on a human task:</p>
<pre><code class="hljs">&lt;planItem id=&quot;planItem1&quot; name=&quot;Task 1&quot; definitionRef=&quot;humanTask1&quot;&gt;
    &lt;itemControl&gt;
        &lt;repetitionRule&gt;&lt;/repetitionRule&gt;
    &lt;/itemControl&gt;
    &lt;exitCriterion id=&quot;exitCriterion1&quot; sentryRef=&quot;sentry1&quot; flowable:exitType=&quot;activeAndEnabledInstances&quot;&gt;&lt;/exitCriterion&gt;
&lt;/planItem&gt;
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="exiteventtype"></a><a href="#exiteventtype" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>exitEventType</h5>
<p>This attribute can be used for exit sentries on stages or the case plan model as it offers an alternative exit than terminate. Imagine a stage where you don’t want to put autocompletion on, but rather have a user listener becoming available whenever the stage is completable and let the user decide when the stage should actually complete by triggering an exit sentry on the stage.
Using this combination according to spec will exit the stage and leave it in terminated state and triggering the exit event for further processing.
Maybe not what you want. With the <em>exitEventType</em> you can specify how the stage is exiting other than the default behavior.</p>
<p>Possible values are:</p>
<ul>
<li><p><strong>exit</strong> This is the default behavior compliant to the spec. It will terminate the stage and all of its children and leave it <em>terminated</em> state, using <em>exit</em> as the event type being triggered.</p></li>
<li><p><strong>complete</strong> This value can be used to terminate the stage, but leave it in <em>completed</em> state (instead of <em>terminated</em>) and trigger the <em>complete</em> event, instead of the <em>exit</em> one. Basically, this behavior is exactly the same as if the stage would have been auto-completed. The engine will throw an exception, if the stage is not completable at the moment the exit sentry with this exit event type is triggered.</p></li>
<li><p><strong>forceComplete</strong> This value is similar to the <em>complete</em> one, but does not check the stage to be completable upfront, but forces it to complete, even if there are still active child plan items at the moment the exit sentry is triggered. They will be terminated first, then the stage completes with <em>complete</em> event and be left in <em>completed</em> state.</p></li>
</ul>
<p>Full example on how to use the exit event type attribute in combination with a user listener to manually complete the stage.
It contains two important parts: the <em>flowable:exitEventType=&quot;complete&quot;</em> attribute on the exit criterion and the <em>flowable:availableCondition=&quot;${cmmn:isStageCompletable()}&quot;</em> on the user event listener which makes the listener only available, if the stage is currently completable, otherwise it is unavailable.
Once the user listener triggers, the exit sentry is executed and will complete the stage, not terminate it and leave it in <em>completed</em> state, triggering the <em>complete</em> event, not the <em>exit</em> event.</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn-exit-sentry-on-stage.png" alt="cmmn exit sentry on stage"></p>
<p>Here you find the CMMN model in XML:</p>
<pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;definitions xmlns=&quot;http://www.omg.org/spec/CMMN/20151109/MODEL&quot;
             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
             xmlns:flowable=&quot;http://flowable.org/cmmn&quot;
             xmlns:cmmndi=&quot;http://www.omg.org/spec/CMMN/20151109/CMMNDI&quot;
             xmlns:dc=&quot;http://www.omg.org/spec/CMMN/20151109/DC&quot;
             xmlns:di=&quot;http://www.omg.org/spec/CMMN/20151109/DI&quot;
             xmlns:design=&quot;http://flowable.org/design&quot;
             targetNamespace=&quot;http://flowable.org/cmmn&quot;&gt;
  &lt;case id=&quot;stageWithUserListenerForCompletion&quot; name=&quot;Stage with user listener for completion&quot;&gt;
    &lt;casePlanModel id=&quot;casePlanModel1&quot; name=&quot;Case plan model&quot;&gt;
      &lt;planItem id=&quot;planItem4&quot; definitionRef=&quot;expandedStage1&quot;&gt;
        &lt;exitCriterion id=&quot;exitCriterion1&quot; flowable:sentryRef=&quot;sentry1&quot; flowable:exitEventType=&quot;complete&quot;&gt;&lt;/exitCriterion&gt;
      &lt;/planItem&gt;
      &lt;sentry id=&quot;sentry1&quot;&gt;
        &lt;planItemOnPart id=&quot;sentryOnPart1&quot; sourceRef=&quot;planItem3&quot;&gt;
          &lt;standardEvent&gt;occur&lt;/standardEvent&gt;
        &lt;/planItemOnPart&gt;
      &lt;/sentry&gt;
      &lt;stage id=&quot;expandedStage1&quot; name=&quot;Stage A&quot;&gt;
        &lt;planItem id=&quot;planItem1&quot; name=&quot;Task A&quot; definitionRef=&quot;humanTask1&quot;&gt;&lt;/planItem&gt;
        &lt;planItem id=&quot;planItem2&quot; name=&quot;Task B&quot; definitionRef=&quot;humanTask2&quot;&gt;
          &lt;itemControl&gt;
            &lt;repetitionRule&gt;&lt;/repetitionRule&gt;
            &lt;manualActivationRule&gt;&lt;/manualActivationRule&gt;
          &lt;/itemControl&gt;
        &lt;/planItem&gt;
        &lt;planItem id=&quot;planItem3&quot; name=&quot;Complete stage&quot; definitionRef=&quot;userEventListener1&quot;&gt;&lt;/planItem&gt;
        &lt;humanTask id=&quot;humanTask1&quot; name=&quot;Task A&quot;&gt;&lt;/humanTask&gt;
        &lt;humanTask id=&quot;humanTask2&quot; name=&quot;Task B&quot;&gt;&lt;/humanTask&gt;
        &lt;userEventListener id=&quot;userEventListener1&quot; name=&quot;Complete stage&quot; flowable:availableCondition=&quot;${cmmn:isStageCompletable()}&quot;&gt;&lt;/userEventListener&gt;
      &lt;/stage&gt;
    &lt;/casePlanModel&gt;
  &lt;/case&gt;
&lt;/definitions&gt;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="event-listeners"></a><a href="#event-listeners" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Event Listeners</h3>
<h4><a class="anchor" aria-hidden="true" id="timer-event-listener"></a><a href="#timer-event-listener" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Timer Event Listener</h4>
<p>A timer event listener is used when the passing of time needs to be captured in a case model.</p>
<p>A timer event listener is not a task and has a simpler plan item lifecycle compared to a <em>task</em>: the timer will simply move from <em>available</em> to <em>completed</em> when the event (in this case, the time passing) occurs.</p>
<p>Properties:</p>
<ul>
<li><p><strong>Timer expression</strong>: an expression that defines when the timer should occur. The following options are possible:</p>
<ul>
<li><p>An expression resolving to a java.util.Date or org.joda.time.DateTime instance (for example, _${someBean.calculateNextDate(someCaseInstanceVariable)})</p></li>
<li><p>An ISO8601 date</p></li>
<li><p>An ISO8601 duration String (for example, <em>PT5H</em>, indicating the timer should fire in 5 hours from instantiation)</p></li>
<li><p>AN ISO8601 repetition String (for example, R5/PT2H, indicating the timer should fire 5 times, each time waiting 2 hours)</p></li>
<li><p>A String containing a cron expression</p></li>
</ul></li>
<li><p><strong>Start trigger plan item/event</strong>: reference to a plan item in the case model that triggers the start of the timer event listener</p></li>
</ul>
<p>Note that setting a <em>start trigger</em> for the timer event listener does not have a visual indicator in the case model, unlike entry/exit criteria on sentries.</p>
<p>A timer event listener is visualized as circle with a clock icon inside:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.timereventlistener.png" alt="cmmn.timereventlistener"></p>
<h4><a class="anchor" aria-hidden="true" id="user-event-listener"></a><a href="#user-event-listener" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>User Event Listener</h4>
<p>A user event listener can be used when needing to capture a user interaction that directly influences a case state,
instead of indirectly via impacting variables or information in the case.
A typical use case for a user event listener are buttons in a UI that a user can click to drive the state of the case instance.
When the event is triggered an <em>Occur</em> event is thrown to which sentries can listener to.
Like timer event listeners, it has a much simpler lifecycle that a <em>task</em>.</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.usereventlistener.png" alt="cmmn.usereventlistener"></p>
<p>User event listeners can be queried using the <em>org.flowable.cmmn.api.runtime.UserEventListenerInstanceQuery</em>. Such a query can be created by calling the <em>cmmnRuntimeService.createUserEventListenerInstanceQuery()</em> method. Note that a user event listener is also a plan item instance, which means it can also be queried through the <em>org.flowable.cmmn.api.runtime.PlanItemInstanceQuery</em> API.</p>
<p>A user event listener can be completed by calling the <em>cmmnRuntimeService.completeUserEventListenerInstance(id)</em> method.</p>
<h4><a class="anchor" aria-hidden="true" id="generic-event-listener"></a><a href="#generic-event-listener" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generic Event Listener</h4>
<p>A generic event listener is used to typically model a programmatic interaction (e.g. a external system that calls out to change something in a case instance).</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.generic-event-listener.png" alt="cmmn.generic event listener"></p>
<p>The API to retrieve and complete these event listeners is on the <em>CmmnRuntimeService</em>:</p>
<pre><code class="hljs">GenericEventListenerInstanceQuery createGenericEventListenerInstanceQuery();
void completeGenericEventListenerInstance(String genericEventListenerInstanceId);
</code></pre>
<p>Similar to <em>user event listeners</em>, this API is a wrapper on top of the <em>PlanItemInstance</em> queries and operations. This means that the data can also be retrieved through the regular <em>PlanItemInstanceQuery</em></p>
<p>Note that generic event listeners are not part of the CMMN specification, but are a Flowable-specific addition.</p>
<h4><a class="anchor" aria-hidden="true" id="automatic-removal-of-event-listeners"></a><a href="#automatic-removal-of-event-listeners" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Automatic removal of event listeners</h4>
<p>The engine will automatically detect when event listeners (user or timer) are not useful anymore.
Take for example the following case definition:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.user-event-listener-removal-1.png" alt="cmmn.user event listener removal 1"></p>
<p>Here, the <em>First stage</em> contains two human tasks (A and B) and it can be exited by a user when the <em>Stop first stage</em> user event is triggered.
However, when both tasks A and B are completed, the stage will also complete. If now the user event listener would be triggered, there is nothing that listens to this event anymore.
The engine will detect this and terminate the user event automatically.</p>
<p>The same mechanism also works for event listeners that are referenced by entry sentries:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.user-event-listener-removal-2.png" alt="cmmn.user event listener removal 2"></p>
<p>In this case, in the case that <em>EventListenerA</em> would be triggered, <em>EventListenerB</em> is terminated (as nothing is listening to its occurrence anymore).</p>
<p>Or, when timer and user event listeners are mixed, the one that is triggered first will also cause the removal of others (when they are not referenced somewhere else):</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.user-event-listener-removal-3.png" alt="cmmn.user event listener removal 3"></p>
<p>Here, the timer will be removed in case the user event is triggered first (and vice versa).</p>
<p>The detection also takes in account plan items that have not yet been created. Take for example the following case definition:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.user-event-listener-removal-4.png" alt="cmmn.user event listener removal 4"></p>
<p>Here, human task <em>C</em> is not yet created when a case instance is started for this case definition. The user event listener will not be removed as long that <em>C</em> has a parent stage that is in a non-terminal state, as this means that the event could still be listened to in the future.</p>
<h4><a class="anchor" aria-hidden="true" id="available-condition"></a><a href="#available-condition" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Available condition</h4>
<p>All types of event listeners can be configured to have a <strong>available condition</strong>: an expressions that will guard the available state of the event listener. To explain the use case, take the following case definition:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.create-condition.png" alt="cmmn.create condition"></p>
<p>When the case instance is started, Stage 1 (as it has no entry criteria) will be moving immediately from <em>available</em> to <em>active</em>. Similar story for human task A. Human task B will move from <em>available</em> to <em>enabled</em> as it’s manually activated.</p>
<p>Normally, also the event listener would become <em>available</em>. The life cycle of event listeners is simpler than that of plan items such as human tasks: an event listener stays in the <em>available</em> state until the event happens. There’s no <em>active</em> state like for other plan items.
This means that a user could trigger it after start and the stage would be exited.</p>
<p>In some use case however, the event listener shouldn’t be <em>available</em> for the user to interact with (or a timer shouldn’t start, when using a timer event listener) unless a certain condition is true.</p>
<p>In the example above, we want to only create it when the stage doesn’t have any active children (or required) anymore. Setting the <strong>availableCondition</strong> to <strong>${cmmn:isStageCompletable()}</strong> will allow the event listener to be created which makes it move immediately to <em>available</em>. Concretely in this model, when human task A is completed Stage 1 becomes <em>completable</em> (as human task B is manually activated and non-required). This makes the <em>availableCondition</em> of the event listener <em>true</em> and the event listener is now available for a user to decide to exit the stage.</p>
<p>Note: this is a Flowable specific addition to the CMMN specification. Without this addition, the event listener would have to be nested within a substage which is protected with entry criteria that listens to the completion of task A.</p>
<p>Note: if this were an autocompletable stage, the engine would complete the stage automatically when A completes.</p>
<h3><a class="anchor" aria-hidden="true" id="item-control-repetition-rule"></a><a href="#item-control-repetition-rule" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Item control: Repetition Rule</h3>
<p>Plan items on the case model can have a <em>repetition rule</em>: an expression that can be used to indicate a certain plan item needs to be repeated.
When no expression is set, but the repetition is enabled (for example, the checkbox is checked in the Flowable Modeler) or the expression is empty, a <em>true</em> value is assumed by default.</p>
<p>An optional <em>repetition counter variable</em> can be set, which holds the index (one-based) of the instance. If not set, the default variable name is <em>repetitionCounter</em>.</p>
<p>If the plan item does not have any entry criteria, the repetition rule expression is evaluated when the plan item is completed or terminated. If the expression resolved to <em>true</em>, a new instance is created. For example, a human task with a repetition rule expression <em>${repetitionCounter &lt; 3}</em>, will create three sequential human tasks.</p>
<p>If the plan item has entry criteria, the behavior is different. The repetition rule is not evaluated on completion or termination, but when a sentry of the plan item is satisfied. If both the sentry is satisfied and the repetition rule evaluates to true, a new instance is created.</p>
<p>Take, for example, the following timer event listener followed by a human task. The sentry has one entry criterion for the <em>occur</em> event of the timer event listener. Note that enabling and setting the repetition rule on the task has a visual indicator at the bottom of the rectangle.</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.repeatingtimereventlistener.png" alt="cmmn.repeatingtimereventlistener"></p>
<p>If the timer event listener is repeating (for example, <em>R/PT1H</em>), the <em>occur</em> event will be fired every hour. When the repetition rule expression of the human task evaluates to true, a new human task instance will be created each hour.</p>
<p>Note that Flowable allows to have repeating user and generic event listeners. This is contrary to the CMMN specification (which disallows it), but we believe it is needed for having a more flexible way of using event listeners (for example to model a case where a user might multiple times trigger an action that leads to the creation of tasks).</p>
<h4><a class="anchor" aria-hidden="true" id="repetition-rule-max-instance-count-attribute"></a><a href="#repetition-rule-max-instance-count-attribute" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Repetition Rule: Max instance count attribute</h4>
<p>There is an extended attribute in the Flowable CMMN model for the repetition rule to take more control about the number of concurrently active plan item instances.
Let’s assume you have a plan item with repetition and an entry sentry with a condition. According to the specification, this would create an endless number of plan item instances as long as the condition is true, which might not be the desired behavior.
With the <em>maxInstanceCount</em> attribute on the repetition rule, you can define, if there might be an unlimited number of instances (default according to the spec) or if there should be only one instance at a time or any particular maximum instance count.
If you have repetition and set the <em>maxInstanceCount</em> to <em>unlimited</em>, you need to control the condition in a way that it only creates as many instances as you want or combine it with an on-part (trigger) to only create a new instances whenever that trigger is fired.</p>
<p>Example with a user task having repetition in combination with an entry sentry and a condition and making sure there is only one instance created at a time:</p>
<pre><code class="hljs">...
&lt;planItem id=&quot;planItem1&quot; name=&quot;Task 1&quot; definitionRef=&quot;humanTask1&quot;&gt;
  &lt;itemControl&gt;
    &lt;repetitionRule flowable:maxInstanceCount=&quot;1&quot;&gt;&lt;/repetitionRule&gt;
  &lt;/itemControl&gt;
  &lt;entryCriterion id=&quot;entryCriterion1&quot; flowable:sentryRef=&quot;sentry1&quot;&gt;&lt;/entryCriterion&gt;
&lt;/planItem&gt;
&lt;sentry id=&quot;sentry1&quot;&gt;
  &lt;ifPart&gt;
    &lt;condition&gt;&lt;![CDATA[${vars:getOrDefault('enableTaskA', false)}]]&gt;&lt;/condition&gt;
  &lt;/ifPart&gt;
&lt;/sentry&gt;
...
</code></pre>
<p>Example with a user task having repetition and a repetition condition to control the number of instances being created (in this example 5 tasks will be created):</p>
<pre><code class="hljs">&lt;planItem id=&quot;planItem1&quot; name=&quot;Task 1&quot; definitionRef=&quot;humanTask1&quot;&gt;
  &lt;itemControl&gt;
    &lt;repetitionRule flowable:counterVariable=&quot;repetitionCounter&quot; flowable:maxInstanceCount=&quot;unlimited&quot;&gt;
      &lt;condition&gt;&lt;![CDATA[${vars:getOrDefault('repetitionCounter', 0) &lt;= 5}]]&gt;&lt;/condition&gt;
    &lt;/repetitionRule&gt;
  &lt;/itemControl&gt;
&lt;/planItem&gt;
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="repetition-rule-repetition-collection-variable"></a><a href="#repetition-rule-repetition-collection-variable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Repetition Rule: Repetition collection variable</h4>
<p>Similar to the multi instance type in BPMN, you can also use the repetition rule in CMMN in combination with items in a collection.
There are extended attributes for the repetition rule to make use of a collection of elements to create plan item instances for.</p>
<p>Here is the list of the available, extended attributes to control the repetition rule out of a collection (list) of items:</p>
<ul>
<li><p><strong>collectionVariable</strong>, set this attribute to the name of the variable with the collection or an expression resolving to a collection</p></li>
<li><p><strong>elementVariable</strong>, if the collection variable is set, you can optionally set an element variable to be used at runtime to hold the element as a local variable of the plan item instance</p></li>
<li><p><strong>elementIndexVariable</strong>, if the collection variable is set, you can optionally set an element index variable to be used at runtime to hold the index (0 based) as a local variable of the plan item instance</p></li>
</ul>
<p>Depending on how the collection gets used with repetition, the time when it is evaluated might be a bit different.</p>
<p>If there is an on-part (an event triggering the plan item) combined with the collection variable, it gets evaluated whenever that on-part is triggered and if the collection is null or empty at that time, no plan item instances are created.</p>
<p>If there is an on-part in combination with an if-part and a collection based repetition, the behavior is the same, however, the if-part might have deferred event trigger handling, which means the plan item is waiting for the if-part to be satisfied, before the collection is checked for the repetition.
Or in other words: the collection needs to be present at the time the if-part is satisfied and the on-part triggers (or was triggered before), then the collection gets evaluated and according its elements, new plan item instances are being started.</p>
<p>If there is no on-part and no if-part, the collection variable gets evaluated every on every evaluation cycle and as soon as it is not null, it is used to create new plan item instances, even if it is empty.
This is done once and the plan item is then terminated. When using a repetition on collection that way, make sure the collection variable becomes available exactly at the moment you want to evaluate it for repetition, otherwise, combine it with an if-part.</p>
<p>If there is an if-part (but no on-part) in combination with a collection variable for repetition, evaluation waits until the if-part is satisfied and afterwards, the collection variable is evaluated to be non-null.
When the if-part is satisfied and the collection is not null (but might be empty), the collection is used for repetition, then the plan item terminates.</p>
<p>Here is an example of a repetition rule combined with a collection variable:</p>
<pre><code class="hljs">&lt;planItem id=&quot;planItem1&quot; name=&quot;Task (${vars:getOrDefault('item', 'na')} - ${vars:getOrDefault('itemIndex', 'na')})&quot; definitionRef=&quot;humanTask1&quot;&gt;
    &lt;itemControl&gt;
        &lt;repetitionRule flowable:counterVariable=&quot;repetitionCounter&quot; flowable:collectionVariable=&quot;myCollection&quot; flowable:elementVariable=&quot;item&quot; flowable:elementIndexVariable=&quot;itemIndex&quot;&gt;&lt;/repetitionRule&gt;
    &lt;/itemControl&gt;
&lt;/planItem&gt;
</code></pre>
<p>The example uses a collection variable named <em>myCollection</em> and has an element and even element index variable specified. They both get used for the plan item instance name used in its name expression.
As there is no entry sentry, the collection gets evaluated in each evaluation cycle and as soon as <em>myCollection</em> is no longer null, it is used for repetition.</p>
<h3><a class="anchor" aria-hidden="true" id="item-control-manual-activation-rule"></a><a href="#item-control-manual-activation-rule" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Item control: Manual Activation Rule</h3>
<p>Plan items on the case model can have a <em>manual activation rule</em>: an expression that can be used to indicate a certain plan item needs to be <em>manually activated by an end-user</em>.
When no expression is set, but the manual activation is enabled (for example, the checkbox is checked in the Flowable Modeler) or the expression is empty, a <em>true</em> value is assumed by default.</p>
<p>Stages and all task types can be marked for manual activation. Visually, the task or stage will get a 'play' icon (small triangle pointing to the right) to indicate an end-user will have to manually activate it:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.manual-activation.png" alt="cmmn.manual activation"></p>
<p>Normally, when a sentry for a plan item is satisfied (or the plan item doesn’t have any sentries) the plan item instance is automatically moved to the <em>ACTIVE</em> state. When a manual activation is set though, and it evaluates to true, the plan item instance now becomes <em>ENABLED</em> instead of <em>ACTIVE</em>. As the name implies, the idea behind this is that end-users manually have to activate the plan item instance. A typical use case is showing a list of buttons of potential plan item instances that can currently be started by the end user.</p>
<p>To start an enabled plan item instance, the <em>startPlanItemInstance</em> method of the <em>CmmnRuntimeService</em> can be used:</p>
<pre><code class="hljs">List&lt;PlanItemInstance&gt; enabledPlanItemInstances = cmmnRuntimeService.createPlanItemInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .planItemInstanceStateEnabled()
    .list();

// ...

cmmnRuntimeService.startPlanItemInstance(planItemInstance.getId());
</code></pre>
<p>Note that the behavior of a task is only executed when the plan item instance moves into the <em>ACTIVE</em> state. For example, for a human task, the user task will only be created after calling the <em>startPlanItemInstance</em> method.</p>
<p>Plan item instances that are enabled can be moved into the <em>DISABLED</em> state:</p>
<pre><code class="hljs">cmmnRuntimeService.disablePlanItemInstance(planItemInstance.getId());
</code></pre>
<p>Disabled plan item instances can be enabled again:</p>
<pre><code class="hljs">cmmnRuntimeService.enablePlanItemInstance(planItemInstance.getId());
</code></pre>
<p>Note that with regards to determining stage or case instance termination, the <em>DISABLED</em> state is seen as a 'terminal' state. This means that the case instance will terminate when only disabled plan item instances would remain.</p>
<h3><a class="anchor" aria-hidden="true" id="item-control-required-rule"></a><a href="#item-control-required-rule" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Item control: Required Rule</h3>
<p>Plan items on the case model can have a <em>required rule</em>: an expression that can be used to indicate a certain plan item is <em>required by the enclosing stage (or plan model)</em>. This can be used to indicate which plan items of the case model are required to be executed and which are optional.</p>
<p>When no expression is set, but the required rule is enabled (for example, the checkbox is checked in the Flowable Modeler) or the expression is empty, a <em>true</em> value is assumed by default.</p>
<p>The <em>required rule</em> works in conjunction with the <em>autoComplete</em> attribute on the parent stage:</p>
<ul>
<li><p>If <em>autoComplete</em> resolves to <em>false</em> for the stage, which is also the default when nothing is set, <strong>all</strong> child plan item instances must be in an end state (completed, terminated, and so on) for the stage plan item instance to be completed by the engine</p></li>
<li><p>If <em>autoComplete</em> resolves to <em>true</em> for the stage, all child plan item instances for <strong>which the required rule evaluates to true</strong> need to be in an end state. If there are also no other active child plan item instances, the stage completes automatically</p></li>
</ul>
<p>A <em>stage plan item instance</em> has a <strong>completable</strong> property that can be used to see whether or not the conditions for completion are satisfied.
Take, for example, the following simple stage and assume that the sentry for the <em>required task</em> evaluates to true and the other one to false. This means that the left plan item instance will be active while the right one will be in the <em>available</em> state.</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.completeable-stage.png" alt="cmmn.completeable stage"></p>
<p>Calling <em>cmmnRuntimeService.completeStagePlanItemInstance(String stagePlanItemInstanceId)</em> will not be possible for the stage (an exception will be thrown) as it has one active child plan item instance. When this user task on the left is completed, the <em>completeStagePlanItemInstance</em> can now be called, as no child plan item instances are currently active. However, by itself, the stage will not automatically complete as the right user task is in the available state.</p>
<p>If the previous stage is changed to be <strong>autocompletable</strong> (this is visualised by a black rectangle at the bottom of the stage) and the plan item on the left is changed to be required (this is visualised using an exclamation mark), the behavior will be different:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.completeable-stage02.png" alt="cmmn.completeable stage02"></p>
<ul>
<li><p>If the left plan item instance is active (sentry is true) and the right is not (sentry is false). In this case, when the left user task is completed, the stage instance will auto complete as it has no active child plan item instances and all required plan item instances are in an end state</p></li>
<li><p>If both the left and right user tasks are active (sentries are true)</p>
<ul>
<li><p>When the left user task is completed, the stage will not autocomplete as there is still a child plan item instance active</p></li>
<li><p>When the right user task is completed, the stage will not autocomplete as the required left child plan item instance is not in an end state</p></li>
</ul></li>
<li><p>If the left plan item instance is not active and the right is active. In this case, when the right user task is completed the stage will not autocomplete, as the required left user task is not in an end state. It will need to become active and be completed to complete the stage.</p></li>
</ul>
<p>Note that the manual activation rule works independently of the required rule. For example, given the following stage:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.completeable-stage03.png" alt="cmmn.completeable stage03"></p>
<p>Here, user task D is required and user task B is manually activated.</p>
<ul>
<li><p>If D is completed, the stage will automatically complete, as B is not required and it is not active</p></li>
<li><p>If B would be required too, it would need to be manually started (using <em>cmmnRuntimeService.startPlanItemInstance(String planItemInstanceId)</em>) before the stage would automatically complete, even if D would be completed before the manual start of B</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="item-control-completion-neutral-rule"></a><a href="#item-control-completion-neutral-rule" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Item control: Completion Neutral Rule</h3>
<p>Plan items on the case model can have a <em>completion neutral rule</em>: an expression that can be used to indicate a certain plan item is <em>neutral with regards to the completion of its parent stage (or plan model)</em>. This can be used to indicate which plan items of the case model are required to be executed and which are optional, as a more flexible alternative in some use cases to using the <em>required rule</em> and <em>autoComplete</em> .</p>
<p>Note that the <em>Completion Neutral Rule</em> is not a CMMN 1.1 Standard, but a Flowable-specific addition.</p>
<p>Following the specification, a stage with a plan item in state <strong>AVAILABLE</strong> does not complete unless its <em>autoComplete</em> attribute is set <em>true</em> and the plan item is not required. For example, a plan item that has an unsatisfied sentry remains in <strong>AVAILABLE</strong> until the sentry is satisfied. This means that the parent stage would not complete, unless the plan item is marked as <em>not required</em> and the stage is set to <em>autoComplete</em>. The downside is that once a stage is marked as to autoComplete, all child plan items need to have a configuration for the <em>required</em> rule, which is in some use cases tedious and lots of work.</p>
<p>The <em>Completion Neutral Rule</em>, contrary to the autoComplete-required mechanism, works from &quot;bottom-up&quot;: a plan item can be marked individually to be <em>neutral wrt the completion of its parent</em> without having to mark any other plan item.</p>
<p>The <em>Required Rule</em> takes precedence when plan items with both rules both evaluate to <em>true</em>.</p>
<p>To summarize:</p>
<ul>
<li><p>a plan item configured to be <em>&quot;completion neutral&quot;</em> will allow a stage to complete automatically if it’s in <strong>AVAILABLE</strong> state (e.g. waiting for an entry criterion sentry),meaning that such a plan item is neutral with respect to its parent stage completion evaluation.</p></li>
<li><p>a stage will remain <strong>ACTIVE</strong> on any of these conditions:</p>
<ol>
<li><p>It has at least one plan item in <strong>ACTIVE</strong> state</p></li>
<li><p>It has at least one plan item with <em>requiredRule</em> in <strong>AVAILABLE</strong> or <strong>ENABLE</strong> state</p></li>
<li><p>It is not marked as <em>autoComplete</em> and has at least one plan item in <strong>ENABLED</strong> state (irrespective of its <em>requiredRule</em>)</p></li>
<li><p>It is not marked as <em>autoComplete</em> and has at least one plan item in <strong>AVAILABLE</strong> state that is <strong>not</strong> <em>completionNeutral</em></p></li>
</ol></li>
<li><p>a stage will <strong>COMPLETE</strong> if:</p>
<ol>
<li><p>It contains no plan items or all child plan items are in a <em>Terminal</em> or <em>Semi-terminal</em> state (CLOSED, COMPLETED, DISABLED, FAILED)</p></li>
<li><p>It is not marked as <em>autoComplete</em> and all remaining child plan items are in <strong>AVAILABLE</strong> state and are <em>completionNeutral</em> and not <em>required</em></p></li>
<li><p>It is <em>autoComplete</em> and all remaining plan items are <em>not required</em> in <strong>ENABLED</strong> or <strong>AVAILABLE</strong> state (regardless of its completion neutrality, as required rule gets precedence)</p></li>
</ol></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="item-control-parent-completion-rule"></a><a href="#item-control-parent-completion-rule" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Item control: Parent Completion Rule</h3>
<p>In addition to the <em>completion neutral rule</em> (which is going to be deprecated), the <em>parent completion rule</em> offers way more flexibility whenever it comes down to evaluating a stage or the case plan model to be completable.
There is the <em>auto complete</em> possibility to automatically complete a stage whenever all the required and active work is done, but sometimes, you want a more fine-grained way on how existing plan item instances get treated around the evaluation of its parent being completable.
With the parent completion rule, you can define the behavior of a plan item on its parent completion evaluation.</p>
<p>Here is a list of types currently supported for the parent completion rule:</p>
<ul>
<li><p><strong>default</strong>: Use this value if the default behavior is required according the CMMN specification.</p></li>
<li><p><strong>ignore</strong>: With this value, the plan item is fully ignored when it is evaluated for its parent completion state. This is particularly useful, if you have plan items (e.g. a case page) to be ignored completely as they don’t have an impact on the case execution or stage completion evaluation.</p></li>
<li><p><strong>ignoreIfAvailable</strong>: With this value, the plan item only gets ignored, if it is in <em>available</em> state, but will prevent the stage from being completed, if it is <em>active</em> or <em>enabled</em>.</p></li>
<li><p><strong>ignoreIfAvailableOrEnabled</strong>: This value includes the <em>enabled</em> (waiting for manual activation) state to be ignored, only an <em>active</em> instance will prevent the stage from being completed.</p></li>
<li><p><strong>ignoreAfterFirstCompletion</strong>: This value is interesting for instance if you have a user task which has repetition and you want to make sure, it was completed at least once, but afterwards, it must not prevent its parent from being completed, even if it is <em>active</em>.</p></li>
<li><p><strong>ignoreAfterFirstCompletionIfAvailableOrEnabled</strong>: In contrast to the previous one, use this value, if you want a plan item being ignored after its first completion, if it is in <em>available</em> or <em>enabled</em> state, but is currently not <em>active</em>.</p></li>
</ul>
<p>Here is an example on how to use the <strong>parent completion rule</strong> for a plan item. This example uses it in combination with repetition, the required rule and even manual activation.
So it will prevent it’s parent from being completed, if it was not started and completed at least once, but no longer, if it was completed once and is not in <em>active</em> state afterwards.</p>
<pre><code class="hljs">&lt;planItem id=&quot;planItem1&quot; name=&quot;Task A&quot; definitionRef=&quot;humanTask1&quot;&gt;
    &lt;itemControl&gt;
        &lt;extensionElements&gt;
            &lt;flowable:parentCompletionRule type=&quot;ignoreAfterFirstCompletionIfAvailableOrEnabled&quot; /&gt;
        &lt;/extensionElements&gt;
        &lt;repetitionRule&gt;&lt;/repetitionRule&gt;
        &lt;requiredRule&gt;&lt;/requiredRule&gt;
        &lt;manualActivationRule&gt;&lt;/manualActivationRule&gt;
    &lt;/itemControl&gt;
&lt;/planItem&gt;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="sentry-evaluation"></a><a href="#sentry-evaluation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sentry evaluation</h2>
<p>Sentries play a big role in any case definition as they offer a powerful way of configuring in a declarative way when certain plan item instances activate or when they are automatically stopped.
As such, one of the most important parts of the Flowable CMMN engine core logic is to evaluate the sentries to see what state changes happen in a case instance.</p>
<h3><a class="anchor" aria-hidden="true" id="when-are-sentries-evaluated"></a><a href="#when-are-sentries-evaluated" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>When are sentries evaluated?</h3>
<p>Sentries are evaluated whenever state changes happen in the case instance or new events happen. Concretely this means:</p>
<ul>
<li><p>When a case instance is started.</p></li>
<li><p>When a wait state plan item such as a human task is triggered to continue.</p></li>
<li><p>When variables related to the case instance change (added, updated or deleted).</p></li>
<li><p>When the state of a plan item instance is changed (e.g. terminated through RuntimeService, a manual plan item instance is started, etc.).</p></li>
<li><p>When manually triggered through the RuntimeService#evaluateCriteria method.</p></li>
</ul>
<p>The engine will continue to plan new evaluations of all currently active sentries as long as changes keep happening.
For example, suppose the completion of a human task satisfies the exit sentry of another human task. The state change of the second human task will again schedule a new evaluation of all active sentries with this new information. When no changes have happened during the last evaluation, the engine deems the state stable and evaluation is stopped.</p>
<h3><a class="anchor" aria-hidden="true" id="concepts"></a><a href="#concepts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concepts</h3>
<p>Sentries consist of two parts:</p>
<ul>
<li><p>One or more <em>onParts</em> that reference lifecycle events from other plan items</p></li>
<li><p>Zero or one ifPart with a condition</p></li>
</ul>
<p>Take for example the following case definition:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.sentry-eval-01.png" alt="cmmn.sentry eval 01"></p>
<p>Assume (not shown in the diagram here)</p>
<ul>
<li><p>The entry sentry on task C listens to the <em>complete</em> event from task A and B.</p></li>
<li><p>The exit sentry listens to the <em>occur</em> event of the user event listener <em>'Stop C'</em></p></li>
<li><p>The entry sentry has a condition expression set to <em>${var:eq(myVar, 'hello world')}</em></p></li>
</ul>
<p>In this simple example, the <em>entry sentry</em> has two onParts and one ifPart. The <em>exit sentry</em> only has onPart.</p>
<p>When the case instance is started, human tasks A and B are created (as they have no entry sentry) and move immediately to state <em>active</em>. C is not <em>active</em>, but <em>available</em> as the sentry has not yet been satisfied. The user event listener <em>'Stop C'</em> is also <em>available</em> from the start and it can thus be triggered.</p>
<p>When both task A and B have been completed and the variable <em>myVar</em> is set to <em>'hello world'</em>, the entry sentry is satisfied and fires. The plan item instance behind C is moved to the <em>active</em> state and as a side-effect the human task C is created (it can now be queried through the <em>TaskService</em> for example).
When <em>'Stop C'</em> is triggered (through the <em>CmmnRuntimeService#completeUserEventListenerInstance</em> method, the exit sentry for C is satisfied and C is terminated.</p>
<p>If <em>'Stop C'</em> would be triggered before C moves to <em>active</em>, its plan item instance would be terminated and the entry sentry won’t be listening anymore to anything.</p>
<h3><a class="anchor" aria-hidden="true" id="default-behavior"></a><a href="#default-behavior" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Default behavior</h3>
<p>When the case instance is started</p>
<pre><code class="hljs">CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
    .caseDefinitionKey(&quot;myCase&quot;)
    .start();
</code></pre>
<p>the condition on the entry sentry is immediately evaluated, as a regular evaluation cycle happens on case instance start.</p>
<p>Note that, if an expression for the condition like <em>${myVar == 'hello world'}</em> would be used this would not work. The engine would throw a <em>PropertyNotFound</em> exception as it doesn’t know the <em>myVar</em> variable.</p>
<p>To solve this:</p>
<ul>
<li><p>pass a variable value for <em>myVar</em> on case instance start</p></li>
<li><p>do a null check in the expression, like <em>${planItemInstance.getVariable('myVar') != null &amp;&amp; planItemInstance.getVariable('myVar') == 'hello world'}</em></p></li>
<li><p>or (and probably easiest), check <a href="/open-source/docs/cmmn/ch03-API#expression-functions">expression functions</a> to use a function such as <em>${var:eq(myVar, 'hello world')}</em> which takes in account the fact the variable might not exist.</p></li>
</ul>
<p><strong>The default evaluation logic has &quot;memory&quot;, which means that when a part of a sentry is satisfied the engine will store and &quot;remember&quot; this in subsequent evaluations.</strong></p>
<p>This means that, from the moment a part (an onPart or ifPart of the sentry) is satisfied, that particular part is not evaluated anymore in next evaluations and it is deemed true.</p>
<p>In the example above, this is needed as task A will typically be completed at another point in time than task B. For example if task A is completed, the part of the sentry on task C that says &quot;i’m listening to the complete event of task A&quot; is now satisfied and this fact is remembered for the future. If now B completes, this is also stored. If now the <em>myVar</em> variable gets the right value, the ifPart also fires and the whole sentry fires and task C gets activated. Of course, it could also be that the variable value is satisfied first and the tasks after. The point is that it doesn’t matter as the engine will remember the parts that were satisfied in the past.</p>
<p>This behavior &quot;with memory&quot; is the default behavior of the engine and is covered by setting the <em>triggerMode</em> of a sentry to <strong>default</strong>. This is automatically set in the Flowable Modeler when adding a new plan item. When no value has been set (for example when importing a case model from another tool), the <em>triggerMode</em> is assumed to be <em>default</em>.</p>
<h3><a class="anchor" aria-hidden="true" id="trigger-mode-onevent"></a><a href="#trigger-mode-onevent" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Trigger mode &quot;onEvent&quot;</h3>
<p>The default behavior (see previous section) will remember which parts have been satisfied previously. This is the most used and safest approach (and also what is typically expected when reasoning about sentries).</p>
<p>There is an alternative mode of sentry triggering that is called <strong>&quot;onEvent&quot;</strong>. In this mode, the engine will have memory with regards to parts of the sentry and will <strong>not remember</strong> any part that was satisfied in the past. This is sometimes needed in advanced use cases. Take for example the following example:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.sentry-eval-02.png" alt="cmmn.sentry eval 02"></p>
<p>Here, the case model has a stage with with three substages. All substage are repeating. Substage B and C have an entry sentry for the completion of stage B. Also (not visually shown), both sentries have a condition that depends on a variable.</p>
<p>In advanced use cases, it could be wanted or needed that that the sentry parts (and especially the ifPart containing the condition) are evaluated only <em>when the lifecycle event of the dependent plan item</em> happens. In this case, this is the <em>complete</em> event of <em>Stage A</em>. For these use cases, the <em>triggerMode</em> of the sentry can be set to <em>onEvent</em>. As the name implies, this means that the sentry evaluation only happens when a referenced event happens and no memory of past things are taken into account.</p>
<p>Concretely, in the example here, the condition of the entry sentries will be evaluated <strong>only</strong> when Stage A completed (and on no other moment). This is very different from the general evaluation rules. In this particular example, it does make managing the variables easier as the conditions are only evaluated on one precise moment and there needs to be no fear of some sentry part being fired due to a variable having a value at a certain point in time. Especially as in the example here all substages are repeating, this would be a lot of work to do. This is a powerful mechanism, but meant for advanced modelers that have an intrinsic knowledge of the case model and the semantics of this triggerMode.</p>
<p>Do note that the engine deems all events to happen simultaneously when it comes to evaluating sentries. Take the following case definition:</p>
<p><img src="/open-source/docs/assets/cmmn/cmmn.sentry-eval-03.png" alt="cmmn.sentry eval 03"></p>
<p>Assume that all sentries use the <em>triggerMode onEvent</em> setting. If task A is completed, this exits task B. Task C will now exit too. So, even though there are two distinct lifecycle events (A being completed and B being exited) and one might assume that <em>onEvent</em> literally means that there are two distinct evaluations happening where the memory of the other part of the exit sentry on task C is forgotten, the engine is smart enough to see that they are part of the same evaluation cycle and task C will be exited too.</p>
<p>Technically spoken: there is <em>some</em> memory for the <em>onEvent</em> sentry, more specifically for evaluations that happen during the same API call (or transaction, lower-level spoken).</p>
<p><strong>Important: onEvent is a powerful mechanism and should only be used when the semantics are well understood. It’s possible to create a case model that gets stuck due to not having the correct sentry configuration if the use case is not carefully examined.</strong></p>
<p>(For example, suppose a sentry has an onPart listening to the completion of a plan item and an ifPart with a condition. If the plan item completes - thus triggering the onPart - but a variable used in the condition is missing for some reason …​ the ifPart would never fire and the case instance might get stuck in an unwanted state).</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/open-source/docs/cmmn/ch05-Deployment"><span class="arrow-prev">← </span><span>Deployment</span></a><a class="docs-next button" href="/open-source/docs/cmmn/ch07-architecture"><span>Architecture</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-is-cmmn">What is CMMN?</a></li><li><a href="#basic-concepts-and-terminology">Basic concepts and terminology</a></li><li><a href="#programmatic-example">Programmatic example</a></li><li><a href="#cmmn-11-constructs">CMMN 1.1 Constructs</a><ul class="toc-headings"><li><a href="#stage">Stage</a></li><li><a href="#task">Task</a></li><li><a href="#human-task">Human task</a></li><li><a href="#java-service-task">Java Service task</a></li><li><a href="#decision-task">Decision task</a></li><li><a href="#http-task">Http Task</a></li><li><a href="#script-task">Script Task</a></li><li><a href="#milestone">Milestone</a></li><li><a href="#case-task">Case task</a></li><li><a href="#process-task">Process task</a></li><li><a href="#criteria">Criteria</a></li><li><a href="#event-listeners">Event Listeners</a></li><li><a href="#item-control-repetition-rule">Item control: Repetition Rule</a></li><li><a href="#item-control-manual-activation-rule">Item control: Manual Activation Rule</a></li><li><a href="#item-control-required-rule">Item control: Required Rule</a></li><li><a href="#item-control-completion-neutral-rule">Item control: Completion Neutral Rule</a></li><li><a href="#item-control-parent-completion-rule">Item control: Parent Completion Rule</a></li></ul></li><li><a href="#sentry-evaluation">Sentry evaluation</a><ul class="toc-headings"><li><a href="#when-are-sentries-evaluated">When are sentries evaluated?</a></li><li><a href="#concepts">Concepts</a></li><li><a href="#default-behavior">Default behavior</a></li><li><a href="#trigger-mode-onevent">Trigger mode &quot;onEvent&quot;</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/open-source/docs/" class="nav-home"><img src="/open-source/docs/img/flowable-oss-icon@2.png" alt="Flowable Open Source Documentation"/></a><div><h5>Documentation</h5><a href="/open-source/docs/oss-introduction">Guides</a><a href="/open-source/docs/javadocs">Javadocs</a></div><div><h5>Legal</h5><a href="/open-source/docs/disclaimer">Disclaimer</a><a href="https://flowable.com/disclaimer/">Policies</a></div></section><section class="copyright">Copyright © 2020 Flowable AG</section></footer></div></body></html>